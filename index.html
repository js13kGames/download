<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Download!!!</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<style>
    html, body {
        margin: 0;
        padding: 0;
        background: #000;
    }

    canvas {
        cursor: none;
        padding-left: 0;
        padding-right: 0;
        margin-left: auto;
        margin-right: auto;
        display: block;
    }

    canvas:focus {
        outline: none;
    }
</style>
<body>
    <canvas id="canvas"></canvas>
</body>
<script src="/dist/gim.js"></script>
<script>
let game = new gim.Game('canvas', 500, window.innerHeight)

const Packet = {
    x: game.canvas.width / 2 - 25,
    y: 50,
    width: 40,
    height: 40,
    speed: 4,
    onKeyDown (key, ev) {
        if (key == 'right') 
            packet.x += this.speed
        if (key == 'left') 
            packet.x -= this.speed
        if (key == 'up') 
            packet.y -= this.speed
        if (key == 'down') 
            packet.y += this.speed
    },
    update () {
        if (this.width <= 0) {
            return
        }
        if (this.x >= tunnel.x + tunnel.width - this.width) {
            this.x =  tunnel.x + tunnel.width - this.width - 1
            this.shrink()
        }
        if (this.x <= tunnel.x) {
            this.x = tunnel.x + 1
            this.shrink()
        }
        if (this.width <= 0) {
            game.stop()
            console.log('Download Failed')
            return
        }
    },
    shrink () {
        this.width -= (0.05 * Packet.width)
        this.height -= (0.05 * Packet.height)
    },
    grow () {
        this.width += (0.05 * Packet.width)
        this.height += (0.05 * Packet.height)
    },
    render (ctx) {
        ctx.fillStyle = '#006CAA';
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
}

const Tunnel = {
    x: 0,
    y: 0,
    width: game.canvas.width,
    height: game.canvas.height,
    shrink () {
        this.width -= 0.4
        this.x += 0.2
    },
    update () {
        if (this.width <= 0) {
            return
        }
        if ((this.width <= (Packet.width + 10))) {
            return
        }
        this.shrink()
    },
    render (ctx) {
        ctx.fillStyle = '#fff';
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
}

const Obstacle = {
    x: 0,
    y: game.canvas.height,
    width: 5,
    height: 5,
    speed: 10,
    isCollide (obj) {
        return this.x < obj.x + obj.width && 
            this.x + this.width > obj.x &&
            this.y < obj.y + obj.height && 
            this.y + this.height > obj.y
    },
    randomX () {
        this.x = Math.floor(Math.random() * (game.canvas.height - this.width))
    },
    randomSpeed () {
        this.speed = Math.ceil(Math.random() * (10 - 3) + 3)
    },
    reset () {
        this.y = game.canvas.height
        this.randomX()
        this.randomSpeed()
    },
    update (dt, game) {
        if (this.y < -this.height) {
            this.reset()
        }
        if (this.isCollide(packet)) {
            this.reset()
            packet.shrink()
        }
        if (this.y == game.canvas.height && (tunnel.width <= (Packet.width + 15))) {
            return
        }
        this.y -= this.speed
    },
    render (ctx) {
        ctx.fillStyle = '#000';
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
}

const Finish = {
    x: 0,
    y: game.canvas.height,
    width: Packet.width + 10,
    height: 10,
    isCollide (obj) {
        return this.x < obj.x + obj.width && 
            this.x + this.width > obj.x &&
            this.y < obj.y + obj.height && 
            this.y + this.height > obj.y
    },
    update () {
        this.x = tunnel.x
        if (this.isCollide(packet)) {
            game.stop()
            console.log('Data downloaded at ' + packet.width / Packet.width * 100)
            return
        }
        if ((tunnel.width <= (Packet.width + 15))) {
            this.y -= 0.5
        }
        if (this.y <= game.canvas.height - 10) {
            return
        }
    },
    render (ctx) {
        ctx.fillStyle = 'green';
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
}

let finish = {...Finish}
let tunnel = {...Tunnel}
let packet = {...Packet}
let obstacles = []
for (let i = 0; i < 20; i++) {
    let obs = {...Obstacle}
    obs.randomX()
    obs.randomSpeed()
    obstacles.push(obs)
}

game.keyboard.on('down', (key, ev) => {
    packet.onKeyDown(key, ev)
})

game.on('update', (dt, game) => {
    tunnel.update(dt, game)
    packet.update(dt, game)
    finish.update(dt, game)
    obstacles.forEach(obs => obs.update(dt, game))
})

game.on('render', (stage) => {
    tunnel.render(stage.ctx)
    packet.render(stage.ctx)
    finish.render(stage.ctx)
    obstacles.forEach(obs => obs.render(stage.ctx))
})

setTimeout(() => {
    document.getElementById('canvas').focus()
    game.start()
}, 3000)
</script>
</html>