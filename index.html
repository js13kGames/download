<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Download!!!</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<style>
    canvas {
        cursor: none;
    }
</style>
<body>
    <canvas id="canvas"></canvas>
</body>
<script src="/dist/gim.js"></script>
<script>
let game = new gim.Game('canvas', 400, 700)

let Packet = {
    x: game.canvas.width / 2 - 25,
    y: 50,
    width: 40,
    height: 40,
    shrink() {
        this.width -= (0.02 * this.width)
        this.height -= (0.02 * this.height)
    },
    render(ctx) {
        ctx.fillStyle = 'white';
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
}

let Obstacle = {
    x: 0,
    y: game.canvas.height,
    width: 2,
    height: 2,
    speed: 8,
    isCollide(obj) {
        return this.x < obj.x + obj.width && 
            this.x + this.width > obj.x &&
            this.y < obj.y + obj.height && 
            this.y + this.height > obj.y
    },
    randomX() {
        this.x = Math.floor(Math.random() * (game.canvas.height - this.width))
    },
    randomSpeed() {
        this.speed = Math.ceil(Math.random() * (10 - 1) + 1)
    },
    reset() {
        this.y = game.canvas.height
        this.randomX()
        this.randomSpeed()
    },
    update(dt, game) {
        this.y -= this.speed
        if (this.y < -this.height) {
            this.reset()
        }
        if (this.isCollide(packet)) {
            console.log('tabrakan')
            this.reset()
            packet.shrink()
        }
    },
    render(ctx) {
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
}

let packet = {...Packet}
let obstacles = []
for (let i = 0; i < 35; i++) {
    let obs = {...Obstacle}
    obs.randomX()
    obs.randomSpeed()
    obstacles.push(obs)
}

game.mouse.on('move', (bt, pos, ev) => {
    packet.x = pos.x
    packet.y = pos.y
})

game.on('update', (dt, game) => {
    obstacles.forEach(obs => obs.update(dt, game))
})

game.on('render', (stage) => {
    packet.render(stage.ctx)
    obstacles.forEach(obs => obs.render(stage.ctx))
})

setTimeout(() => game.start(), 2000)
</script>
</html>